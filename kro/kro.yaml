---
# Source: kro/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: kro
  namespace: audiobookshelf
  labels:
    helm.sh/chart: kro-0.4.1
    app.kubernetes.io/name: kro
    app.kubernetes.io/instance: kro
    app.kubernetes.io/version: "0.4.1"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
    app.kubernetes.io/part-of: kro
---
# Source: kro/templates/cluster-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    kubernetes.io/description: |
      This ClusterRole grants access for the kro controller.

      The kro installation comes with enough for the controller to run, and start watching the relevant resources
      (e.g. ResourceGraphDefinitions), but in order to allow kro to create and manage other types of resources you
      must manually grant access to those separately.

      The easiest way to accomplish this is to create a new ClusterRole with the label `rbac.kro.run/aggregate-to-controller: "true"`
      which will be automatically aggregated into this one.
  name: kro:controller
  labels:
    helm.sh/chart: kro-0.4.1
    app.kubernetes.io/name: kro
    app.kubernetes.io/instance: kro
    app.kubernetes.io/version: "0.4.1"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
    app.kubernetes.io/part-of: kro
aggregationRule:
  clusterRoleSelectors:
    - matchLabels:
        'rbac.kro.run/aggregate-to-controller': "true"
---
# Source: kro/templates/cluster-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    kubernetes.io/description: |
      This ClusterRole grants access for the kro controller to resources it always needs access to.
  labels:
    helm.sh/chart: kro-0.4.1
    app.kubernetes.io/name: kro
    app.kubernetes.io/instance: kro
    app.kubernetes.io/version: "0.4.1"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
    app.kubernetes.io/part-of: kro
    rbac.kro.run/aggregate-to-controller: "true"
  name: kro:controller:static
rules:
- apiGroups:
  - kro.run
  resources:
  - resourcegraphdefinitions
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - kro.run
  resources:
  - resourcegraphdefinitions/finalizers
  verbs:
  - update
- apiGroups:
  - kro.run
  resources:
  - resourcegraphdefinitions/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - apiextensions.k8s.io
  resources:
  - customresourcedefinitions
  verbs:
  - create
  - get
  - list
  - watch
  - patch
  - update
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
# Source: kro/templates/cluster-role-binding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kro:controller
  labels:
    helm.sh/chart: kro-0.4.1
    app.kubernetes.io/name: kro
    app.kubernetes.io/instance: kro
    app.kubernetes.io/version: "0.4.1"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
    app.kubernetes.io/part-of: kro
roleRef:
  kind: ClusterRole
  apiGroup: rbac.authorization.k8s.io
  name: kro:controller
subjects:
- kind: ServiceAccount
  name: kro
  namespace: audiobookshelf
---
# Source: kro/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kro
  namespace: audiobookshelf
  labels:
    helm.sh/chart: kro-0.4.1
    app.kubernetes.io/name: kro
    app.kubernetes.io/instance: kro
    app.kubernetes.io/version: "0.4.1"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
    app.kubernetes.io/part-of: kro
spec:
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: kro
      app.kubernetes.io/instance: kro
  template:
    metadata:
      labels:
        helm.sh/chart: kro-0.4.1
        app.kubernetes.io/name: kro
        app.kubernetes.io/instance: kro
        app.kubernetes.io/version: "0.4.1"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: controller
        app.kubernetes.io/part-of: kro
    spec:
      serviceAccountName: kro
      securityContext:
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: kro
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            privileged: false
            runAsNonRoot: true
            runAsUser: 1000
          image: "ghcr.io/kro-run/kro/controller:0.4.1"
          imagePullPolicy: IfNotPresent
          ports:
            - name: metricsport
              containerPort: 8078
          resources:
            limits:
              cpu: 1000m
              memory: 1024Mi
            requests:
              cpu: 256m
              memory: 128Mi
          env:
            - name: KRO_METRICS_BIND_ADDRESS
              value: ":8078"
            - name: KRO_HEALTH_PROBE_BIND_ADDRESS
              value: ":8079"
            - name: KRO_RESOURCE_GROUP_CONCURRENT_RECONCILES
              value: "1"
            - name: KRO_DYNAMIC_CONTROLLER_CONCURRENT_RECONCILES
              value: "1"
            - name: KRO_LOG_LEVEL
              value: "3"
            - name: KRO_DYNAMIC_CONTROLLER_DEFAULT_RESYNC_PERIOD
              value: "36000"
            - name: KRO_DYNAMIC_CONTROLLER_DEFAULT_QUEUE_MAX_RETRIES
              value: "20"
            - name: KRO_DYNAMIC_CONTROLLER_DEFAULT_SHUTDOWN_TIMEOUT
              value: "60"
            - name: KRO_CLIENT_QPS
              value: "100"
            - name: KRO_CLIENT_BURST
              value: "150"
          args:
            - --metrics-bind-address
            - "$(KRO_METRICS_BIND_ADDRESS)"
            - --health-probe-bind-address
            - "$(KRO_HEALTH_PROBE_BIND_ADDRESS)"
            - --resource-graph-definition-concurrent-reconciles
            - "$(KRO_RESOURCE_GROUP_CONCURRENT_RECONCILES)"
            - --dynamic-controller-concurrent-reconciles
            - "$(KRO_DYNAMIC_CONTROLLER_CONCURRENT_RECONCILES)"
            - --log-level
            - "$(KRO_LOG_LEVEL)"
            - --dynamic-controller-default-resync-period
            - "$(KRO_DYNAMIC_CONTROLLER_DEFAULT_RESYNC_PERIOD)"
            - --dynamic-controller-default-queue-max-retries
            - "$(KRO_DYNAMIC_CONTROLLER_DEFAULT_QUEUE_MAX_RETRIES)"
            - --dynamic-controller-default-shutdown-timeout
            - "$(KRO_DYNAMIC_CONTROLLER_DEFAULT_SHUTDOWN_TIMEOUT)"
            - --client-qps
            - "$(KRO_CLIENT_QPS)"
            - --client-burst
            - "$(KRO_CLIENT_BURST)"
            - --leader-elect
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8079
            initialDelaySeconds: 15
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /readyz
              port: 8079
            initialDelaySeconds: 10
            periodSeconds: 10
      nodeSelector:
        kubernetes.io/os: linux
